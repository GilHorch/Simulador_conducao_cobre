<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Condutividade El√©trica - Cobre</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #eab308, #f59e0b, #ef4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #cbd5e1;
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .content {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-bottom: 40px;
        }

        .main-simulation {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 25px;
        }

        @media (max-width: 1200px) {
            .main-simulation {
                grid-template-columns: 1fr;
            }
        }

        .simulation-container {
            background: rgba(255, 255, 255, 0.03);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .simulation-title {
            font-size: 1.8rem;
            color: #eab308;
            font-weight: 600;
        }

        .simulation-stats {
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #60a5fa;
        }

        #simulation-canvas {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.3));
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.03);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 25px;
            overflow-y: auto;
            max-height: 600px;
        }

        .control-section {
            background: rgba(0, 0, 0, 0.25);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .section-title {
            color: #60a5fa;
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title i {
            font-size: 1.4rem;
        }

        .material-selection {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .material-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 15px;
            border-radius: 12px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #60a5fa;
        }

        .material-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
        }

        .material-preview {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 1.2rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .copper-preview {
            background: radial-gradient(circle at 30% 30%, #b45309, #92400e);
            box-shadow: 0 6px 20px rgba(180, 83, 9, 0.4);
        }

        .material-info {
            text-align: center;
        }

        .material-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .material-conductivity {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        button {
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .primary-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .primary-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .toggle-btn {
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #10b981, #059669);
            border: none;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }

        .slider-control {
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #cbd5e1;
            font-size: 0.95rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            border: 2px solid white;
        }

        .info-display {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 18px;
            border-radius: 10px;
            border-left: 4px solid #eab308;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .info-display div {
            font-size: 0.9rem;
            margin: 4px 0;
            display: flex;
            gap: 10px;
        }

        .info-label {
            color: #94a3b8;
            min-width: 120px;
        }

        .info-value {
            color: #60a5fa;
            font-weight: 600;
        }

        .comparison-panel {
            background: rgba(255, 255, 255, 0.03);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
        }

        .comparison-title {
            color: #eab308;
            font-size: 1.8rem;
            margin-bottom: 25px;
            text-align: center;
        }

        .comparison-content {
            display: flex;
            justify-content: center;
            gap: 25px;
        }

        .comparison-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            max-width: 500px;
            width: 100%;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .element-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
        }

        .copper-icon {
            background: radial-gradient(circle at 30% 30%, #b45309, #92400e);
            box-shadow: 0 6px 20px rgba(180, 83, 9, 0.4);
        }

        .element-info h3 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            color: #eab308;
        }

        .conductivity-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .conductivity-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            border-radius: 10px;
        }

        .copper-conductivity {
            width: 98%;
        }

        .properties-list {
            margin-top: 20px;
        }

        .property-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .property-item:last-child {
            border-bottom: none;
        }

        .property-name {
            color: #94a3b8;
        }

        .property-value {
            color: #60a5fa;
            font-weight: 500;
        }

        /* Novos estilos para controles de velocidade */
        .speed-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .speed-control-btn {
            padding: 10px 15px;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .speed-control-btn.active {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }

        /* Indicadores de polo */
        .pole-indicator {
            position: absolute;
            padding: 15px 25px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.1rem;
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .positive-pole {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9));
            border: 3px solid #f87171;
            color: white;
            top: 50px;
            right: 50px;
        }

        .negative-pole {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(29, 78, 216, 0.9));
            border: 3px solid #60a5fa;
            color: white;
            top: 50px;
            left: 50px;
        }

        .pole-icon {
            font-size: 1.5rem;
        }

        /* Estilos para elementos da simula√ß√£o */
        .atom {
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .atom.selected {
            border: 3px solid #3b82f6;
            border-radius: 50%;
            box-shadow: 0 0 30px #3b82f6;
            z-index: 20;
        }

        .conduction-band {
            position: absolute;
            border: 2px solid rgba(16, 185, 129, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.3);
            z-index: 5;
        }

        .conduction-band.highlighted {
            border: 3px solid #10b981;
            box-shadow: 0 0 40px rgba(16, 185, 129, 0.5);
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {
            0% {
                opacity: 0.7;
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            }

            50% {
                opacity: 1;
                box-shadow: 0 0 40px rgba(16, 185, 129, 0.7);
            }

            100% {
                opacity: 0.7;
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            }
        }

        .valence-band {
            position: absolute;
            border: 2px solid rgba(245, 158, 11, 0.5);
            border-radius: 50%;
            z-index: 4;
        }

        .valence-band.highlighted {
            border: 3px solid #f59e0b;
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.4);
        }

        .inner-shell {
            position: absolute;
            border: 1px dashed rgba(255, 255, 255, 0.15);
            border-radius: 50%;
        }

        .nucleus {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 25px;
            z-index: 15;
        }

        .copper-nucleus {
            background: radial-gradient(circle at 30% 30%, #b45309, #92400e);
            box-shadow: 0 0 25px rgba(180, 83, 9, 0.6);
        }

        .electron {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            z-index: 20;
            transition: opacity 0.3s ease;
        }

        .inner-electron {
            background: radial-gradient(circle at 4px 4px, #3b82f6, #1d4ed8);
            box-shadow: 0 0 10px #3b82f6;
        }

        .valence-electron {
            background: radial-gradient(circle at 4px 4px, #f59e0b, #d97706);
            box-shadow: 0 0 10px #f59e0b;
        }

        .free-electron {
            background: radial-gradient(circle at 4px 4px, #f59e0b, #d97706);
            /* Amarelo como val√™ncia */
            box-shadow: 0 0 15px #f59e0b;
            animation: electron-float 3s infinite ease-in-out;
            z-index: 25;
        }

        @keyframes electron-float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }
        }

        .electron-flow {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #10b981;
            border-radius: 50%;
            opacity: 0.7;
            z-index: 5;
        }

        .connection-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, #10b981, transparent);
            transform-origin: 0 0;
            opacity: 0.6;
            z-index: 3;
        }

        .conduction-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #10b981;
            max-width: 300px;
            z-index: 50;
        }

        .conduction-info h4 {
            color: #10b981;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .conduction-info p {
            color: #cbd5e1;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .electron-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .electron-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .electron-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .conduction-color {
            background: #f59e0b;
            /* Agora amarelo */
            box-shadow: 0 0 8px #f59e0b;
        }

        .valence-color {
            background: #f59e0b;
            box-shadow: 0 0 8px #f59e0b;
        }

        .inner-color {
            background: #3b82f6;
            box-shadow: 0 0 8px #3b82f6;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Simulador de Condutividade El√©trica - Cobre</h1>
            <p class="subtitle">El√©trons de val√™ncia (amarelos) se movem do polo negativo (-) para o polo positivo (+)
                quando a tens√£o √© aplicada</p>
        </header>

        <div class="content">
            <div class="main-simulation">
                <div class="simulation-container">
                    <div class="simulation-header">
                        <h2 class="simulation-title">Rede de √Åtomos de Cobre</h2>
                        <div class="simulation-stats">
                            <div class="stat-item">
                                <div class="stat-label">El√©trons Livres</div>
                                <div class="stat-value" id="free-electron-count">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Condutividade</div>
                                <div class="stat-value" id="conductivity-value">98%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">√Åtomos de Cobre</div>
                                <div class="stat-value" id="copper-count">16</div>
                            </div>
                        </div>
                    </div>

                    <div id="simulation-canvas">
                        <!-- Polos e elementos ser√£o adicionados dinamicamente -->

                        <div class="info-display">
                            <div>
                                <span class="info-label">Material:</span>
                                <span class="info-value" id="main-material">Cobre</span>
                            </div>
                            <div>
                                <span class="info-label">El√©trons de Val√™ncia:</span>
                                <span class="info-value" id="valence-count">1</span>
                            </div>
                            <div>
                                <span class="info-label">El√©trons Livres/√Åtomo:</span>
                                <span class="info-value" id="free-per-atom">‚âà1</span>
                            </div>
                        </div>

                        <div class="conduction-info">
                            <h4>üí° Como Funciona a Condu√ß√£o</h4>
                            <p>Quando a tens√£o √© aplicada, el√©trons de val√™ncia (amarelos) se movem do polo negativo (-)
                                para o polo positivo (+).</p>
                        </div>
                    </div>
                </div>

                <div class="controls-panel">
                    <div class="control-section">
                        <h3 class="section-title">üéØ Material</h3>
                        <div class="material-selection">
                            <div class="material-option selected" data-material="Cu">
                                <div class="material-preview copper-preview">Cu</div>
                                <div class="material-info">
                                    <div class="material-name">Cobre</div>
                                    <div class="material-conductivity">Excelente condutor</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <h3 class="section-title">‚ö° Controle de Velocidade</h3>
                        <div class="speed-controls">
                            <button id="speed-conduction" class="speed-control-btn active">‚è© Condu√ß√£o</button>
                            <button id="speed-valence" class="speed-control-btn">‚ö° Val√™ncia</button>
                            <button id="speed-inner" class="speed-control-btn">üåÄ Internas</button>
                            <button id="speed-all" class="speed-control-btn">üéØ Todas</button>
                        </div>

                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Velocidade dos El√©trons</span>
                                <span id="electron-speed-value">70%</span>
                            </div>
                            <input type="range" id="electron-speed" min="0" max="100" value="70">
                        </div>

                        <div class="electron-legend">
                            <div class="electron-legend-item">
                                <div class="electron-color conduction-color"></div>
                                <span>Condu√ß√£o (Val√™ncia)</span>
                            </div>
                            <div class="electron-legend-item">
                                <div class="electron-color inner-color"></div>
                                <span>Internos</span>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <h3 class="section-title">üëÅÔ∏è Controles de Visibilidade</h3>
                        <button id="toggle-electrons" class="toggle-btn active">üëÅÔ∏è Mostrar El√©trons</button>
                        <button id="toggle-conduction" class="toggle-btn active">üîã Camada de Condu√ß√£o</button>
                        <button id="toggle-valence" class="toggle-btn">‚ú® Camada de Val√™ncia</button>
                        <button id="toggle-shells" class="toggle-btn">üîÑ Camadas Internas</button>
                        <button id="toggle-connections" class="toggle-btn">üîó Conex√µes</button>

                        <!-- Novos bot√µes de visibilidade espec√≠ficos -->
                        <button id="toggle-inner-electrons" class="toggle-btn active">üåÄ Mostrar El√©trons
                            Internos</button>
                        <button id="toggle-valence-conduction-electrons" class="toggle-btn active">‚ö° Mostrar El√©trons
                            Val√™ncia/Condu√ß√£o</button>
                    </div>

                    <!--   <div class="control-section">
                        <h3 class="section-title">‚ö° Tens√£o El√©trica</h3>
                        <div class="slider-control">
                            <div class="slider-label">
                                <span>Intensidade do Campo</span>
                                <span id="flow-intensity-value">70%</span>
                            </div>
                            <input type="range" id="flow-intensity" min="0" max="100" value="70">
                        </div>
                        Bot√µes removidos - apenas o controle deslizante permanece 
                    </div>
                    -->

                    <div class="control-section">
                        
                    <!--    <h3 class="section-title">‚ö° A√ß√µes</h3>
                        <button id="apply-voltage" class="primary-btn">‚ö° Aplicar Tens√£o El√©trica</button>
                        <button id="reverse-polarity" class="secondary-btn">üîÑ Inverter Polos</button>
                        <button id="jump-electrons" class="secondary-btn">üîÑ Simular Salto Eletr√¥nico</button>
                        
                    --> 
                        <button id="randomize-atoms" class="secondary-btn">üé≤ Randomizar El√©trons</button>
                        <button id="reset-simulation" class="secondary-btn">üîÑ Resetar Simula√ß√£o</button>
                    </div>
                </div>
            </div>

            <div class="comparison-panel">
                <h2 class="comparison-title">Propriedades do Cobre</h2>
                <div class="comparison-content">
                    <div class="comparison-card">
                        <div class="card-header">
                            <div class="element-icon copper-icon">Cu</div>
                            <div class="element-info">
                                <h3>Cobre (Cu)</h3>
                                <p>Excelente condutor el√©trico</p>
                            </div>
                        </div>

                        <div class="conductivity-bar">
                            <div class="conductivity-fill copper-conductivity"></div>
                        </div>
                        <div style="text-align: center; color: #94a3b8; font-size: 0.9rem; margin-bottom: 20px;">
                            Condutividade: 98% (58.0 √ó 10‚Å∂ S/m)
                        </div>

                        <div class="properties-list">
                            <div class="property-item">
                                <span class="property-name">N√∫mero At√¥mico:</span>
                                <span class="property-value">29</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Configura√ß√£o Eletr√¥nica:</span>
                                <span class="property-value">[Ar] 4s¬π 3d¬π‚Å∞</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">El√©trons de Val√™ncia:</span>
                                <span class="property-value">1</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">El√©trons Livres:</span>
                                <span class="property-value">‚âà0.95 por √°tomo</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Resistividade:</span>
                                <span class="property-value">1.68 √ó 10‚Åª‚Å∏ Œ©¬∑m</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Densidade:</span>
                                <span class="property-value">8.96 g/cm¬≥</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Ponto de Fus√£o:</span>
                                <span class="property-value">1084.62 ¬∞C</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('simulation-canvas');
            const electronSpeedSlider = document.getElementById('electron-speed');
            const flowIntensitySlider = document.getElementById('flow-intensity');
            const electronSpeedValue = document.getElementById('electron-speed-value');
            const flowIntensityValue = document.getElementById('flow-intensity-value');

            // Elementos de estat√≠sticas
            const freeElectronCountElement = document.getElementById('free-electron-count');
            const conductivityValueElement = document.getElementById('conductivity-value');
            const copperCountElement = document.getElementById('copper-count');
            const mainMaterialElement = document.getElementById('main-material');
            const valenceCountElement = document.getElementById('valence-count');
            const freePerAtomElement = document.getElementById('free-per-atom');

            // Bot√µes de controle
            const speedConductionBtn = document.getElementById('speed-conduction');
            const speedValenceBtn = document.getElementById('speed-valence');
            const speedInnerBtn = document.getElementById('speed-inner');
            const speedAllBtn = document.getElementById('speed-all');
            const toggleElectronsBtn = document.getElementById('toggle-electrons');
            const toggleConductionBtn = document.getElementById('toggle-conduction');
            const toggleValenceBtn = document.getElementById('toggle-valence');
            const toggleShellsBtn = document.getElementById('toggle-shells');
            const toggleConnectionsBtn = document.getElementById('toggle-connections');
            const toggleInnerElectronsBtn = document.getElementById('toggle-inner-electrons');
            const toggleValenceConductionElectronsBtn = document.getElementById('toggle-valence-conduction-electrons');
            const applyVoltageBtn = document.getElementById('apply-voltage');
            const reversePolarityBtn = document.getElementById('reverse-polarity');
            const jumpElectronsBtn = document.getElementById('jump-electrons');
            const randomizeAtomsBtn = document.getElementById('randomize-atoms');
            const resetSimulationBtn = document.getElementById('reset-simulation');

            // Vari√°veis de estado
            let animationId = null;
            let electronAngle = 0;
            let freeElectronAngle = 0;
            let showElectrons = true;
            let showConductionBand = true;
            let showValenceBand = false;
            let showInnerShells = false;
            let showConnections = true;
            let voltageApplied = false;
            let currentSpeedControl = 'conduction';

            // Estados espec√≠ficos para os novos bot√µes
            let showInnerElectrons = true;
            let showValenceConductionElectrons = true;

            // Posi√ß√µes dos polos (esquerda: negativo, direita: positivo)
            let negativePolePosition = { x: 50, y: 50 };
            let positivePolePosition = { x: canvas.offsetWidth - 150, y: 50 };
            let electronFlowDirection = 1; // 1: negativo ‚Üí positivo, -1: positivo ‚Üí negativo

            // Contadores
            let copperCount = 0;
            let totalFreeElectrons = 0;
            let conductivityPercentage = 98;

            // Elementos de polo
            let positivePoleElement = null;
            let negativePoleElement = null;

            const canvasWidth = canvas.offsetWidth;
            const canvasHeight = canvas.offsetHeight;

            // Configura√ß√£o da grade
            const gridSize = 4;
            const atomSpacing = 200;
            const startX = (canvasWidth - (gridSize - 1) * atomSpacing) / 2;
            const startY = (canvasHeight - (gridSize - 1) * atomSpacing) / 2;

            // Armazenamento de dados
            const atoms = [];
            const conductionBands = [];
            const freeElectrons = []; // El√©trons de val√™ncia na camada de condu√ß√£o
            const valenceElectrons = []; // El√©trons que ainda est√£o nas √≥rbitas de val√™ncia
            const innerElectrons = []; // El√©trons nas camadas internas
            const connectionLines = [];

            // Configura√ß√µes do cobre
            const copperConfig = {
                name: 'Cobre',
                symbol: 'Cu',
                atomicNumber: 29,
                valenceElectrons: 1,
                freeElectronsPerAtom: 0.95,
                conductivity: 58.0,
                color: 'copper',
                electronConfig: [
                    { radius: 30, electrons: 2, speed: 1.5, type: 'inner' },
                    { radius: 60, electrons: 8, speed: 1.2, type: 'inner' },
                    { radius: 90, electrons: 18, speed: 1.0, type: 'inner' },
                    { radius: 120, electrons: 1, speed: 0.8, type: 'valence' }
                ]
            };

            // Inicializar simula√ß√£o
            initializeSimulation();

            function initializeSimulation() {
                // Limpar canvas
                canvas.innerHTML = `
                    <div class="info-display">
                        <div>
                            <span class="info-label">Material:</span>
                            <span class="info-value" id="main-material">Cobre</span>
                        </div>
                        <div>
                            <span class="info-label">El√©trons de Val√™ncia:</span>
                                <span class="info-value" id="valence-count">1</span>
                            </div>
                            <div>
                                <span class="info-label">El√©trons Livres/√Åtomo:</span>
                                <span class="info-value" id="free-per-atom">‚âà1</span>
                            </div>
                        </div>
                        <div class="conduction-info">
                            <h4>üí° Como Funciona a Condu√ß√£o</h4>
                            <p>Quando a tens√£o √© aplicada, el√©trons de val√™ncia (amarelos) se movem do polo negativo (-) para o polo positivo (+).</p>
                        </div>
                    `;

                // Resetar contadores
                copperCount = 0;
                totalFreeElectrons = 0;
                conductivityPercentage = 98;

                // Resetar arrays
                atoms.length = 0;
                conductionBands.length = 0;
                freeElectrons.length = 0;
                valenceElectrons.length = 0;
                innerElectrons.length = 0;
                connectionLines.length = 0;

                // Resetar dire√ß√£o do fluxo
                electronFlowDirection = 1;

                // Resetar estados de visibilidade
                showInnerElectrons = true;
                showValenceConductionElectrons = true;

                // Criar rede de √°tomos (todos cobre)
                createAtomNetwork();

                // Criar conex√µes entre √°tomos
                createConnections();

                // Criar indicadores de polo
                createPoleIndicators();

                // Atualizar estat√≠sticas
                updateStats();
            }

            function createPoleIndicators() {
                // Remover polos existentes
                if (positivePoleElement) positivePoleElement.remove();
                if (negativePoleElement) negativePoleElement.remove();

                // Atualizar posi√ß√µes baseado na dire√ß√£o do fluxo
                if (electronFlowDirection === 1) {
                    // Fluxo normal: negativo (esquerda) ‚Üí positivo (direita)
                    negativePolePosition = { x: 50, y: 50 };
                    positivePolePosition = { x: canvas.offsetWidth - 150, y: 50 };
                } else {
                    // Fluxo invertido: negativo (direita) ‚Üí positivo (esquerda)
                    negativePolePosition = { x: canvas.offsetWidth - 150, y: 50 };
                    positivePolePosition = { x: 50, y: 50 };
                }

                // Criar polo positivo
                positivePoleElement = document.createElement('div');
                positivePoleElement.className = 'pole-indicator positive-pole';
                positivePoleElement.innerHTML = '<span class="pole-icon">+</span> <span>Polo Positivo</span>';
                positivePoleElement.style.display = voltageApplied ? 'flex' : 'none';
                positivePoleElement.style.left = `${positivePolePosition.x}px`;
                positivePoleElement.style.top = `${positivePolePosition.y}px`;
                canvas.appendChild(positivePoleElement);

                // Criar polo negativo
                negativePoleElement = document.createElement('div');
                negativePoleElement.className = 'pole-indicator negative-pole';
                negativePoleElement.innerHTML = '<span class="pole-icon">-</span> <span>Polo Negativo</span>';
                negativePoleElement.style.display = voltageApplied ? 'flex' : 'none';
                negativePoleElement.style.left = `${negativePolePosition.x}px`;
                negativePoleElement.style.top = `${negativePolePosition.y}px`;
                canvas.appendChild(negativePoleElement);
            }

            function createAtomNetwork() {
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const centerX = startX + col * atomSpacing;
                        const centerY = startY + row * atomSpacing;
                        const atomId = row * gridSize + col;

                        // Criar √°tomo de cobre
                        createAtom(centerX, centerY, atomId);
                    }
                }

                // Atualizar contador
                copperCount = gridSize * gridSize;
            }

            function createAtom(centerX, centerY, atomId) {
                const materialConfig = copperConfig;
                const atomData = {
                    id: atomId,
                    centerX: centerX,
                    centerY: centerY,
                    electronShells: [],
                    electrons: [],
                    nucleus: null,
                    container: null,
                    freeElectrons: [],
                    valenceElectrons: [],
                    innerElectrons: []
                };

                atoms[atomId] = atomData;

                // Criar container do √°tomo
                const container = document.createElement('div');
                container.className = 'atom';
                container.style.left = `${centerX - 70}px`;
                container.style.top = `${centerY - 70}px`;
                container.style.width = '140px';
                container.style.height = '140px';
                container.dataset.atomId = atomId;

                canvas.appendChild(container);
                atomData.container = container;

                // Criar n√∫cleo
                const nucleus = document.createElement('div');
                nucleus.className = 'nucleus copper-nucleus';
                nucleus.style.width = '45px';
                nucleus.style.height = '45px';
                nucleus.style.left = '47.5px';
                nucleus.style.top = '47.5px';
                container.appendChild(nucleus);
                atomData.nucleus = nucleus;

                // Criar camadas eletr√¥nicas
                materialConfig.electronConfig.forEach((shell, shellIndex) => {
                    // Criar orbital
                    const orbital = document.createElement('div');
                    if (shell.type === 'valence') {
                        orbital.className = 'valence-band';
                        if (showValenceBand) {
                            orbital.classList.add('highlighted');
                        }
                    } else {
                        orbital.className = 'inner-shell';
                        orbital.style.display = showInnerShells ? 'block' : 'none';
                    }

                    orbital.style.width = `${shell.radius * 2}px`;
                    orbital.style.height = `${shell.radius * 2}px`;
                    orbital.style.left = `${70 - shell.radius}px`;
                    orbital.style.top = `${70 - shell.radius}px`;

                    container.appendChild(orbital);
                    atomData.electronShells.push(orbital);

                    // Criar el√©trons para esta camada
                    const angleStep = (2 * Math.PI) / shell.electrons;

                    for (let i = 0; i < shell.electrons; i++) {
                        const electron = document.createElement('div');
                        if (shell.type === 'valence') {
                            electron.className = 'valence-electron electron';
                        } else {
                            electron.className = 'inner-electron electron';
                        }

                        // Aplicar visibilidade espec√≠fica
                        if (shell.type === 'valence') {
                            electron.style.opacity = showElectrons && showValenceConductionElectrons ? '1' : '0';
                        } else {
                            electron.style.opacity = showElectrons && showInnerElectrons ? '1' : '0';
                        }

                        const angle = i * angleStep;
                        const x = 70 + shell.radius * Math.cos(angle);
                        const y = 70 + shell.radius * Math.sin(angle);

                        electron.style.left = `${x - 7}px`;
                        electron.style.top = `${y - 7}px`;

                        container.appendChild(electron);

                        const electronData = {
                            element: electron,
                            atomId: atomId,
                            shellIndex: shellIndex,
                            angle: angle,
                            radius: shell.radius,
                            speed: shell.speed,
                            type: shell.type,
                            isFree: false
                        };

                        atomData.electrons.push(electronData);

                        // Armazenar em arrays espec√≠ficos
                        if (shell.type === 'valence') {
                            atomData.valenceElectrons.push(electronData);
                            valenceElectrons.push(electronData);
                        } else {
                            atomData.innerElectrons.push(electronData);
                            innerElectrons.push(electronData);
                        }
                    }
                });

                // Criar camada de condu√ß√£o para este √°tomo
                createConductionBand(centerX, centerY, atomId);

                // Criar el√©trons livres (el√©trons de val√™ncia que saltaram para condu√ß√£o)
                createFreeElectronsForAtom(atomId);
            }

            function createConductionBand(centerX, centerY, atomId) {
                const conductionBand = document.createElement('div');
                conductionBand.className = 'conduction-band';
                if (showConductionBand) {
                    conductionBand.classList.add('highlighted');
                }

                // Camada de condu√ß√£o maior que as outras
                const conductionRadius = 150;
                conductionBand.style.width = `${conductionRadius * 2}px`;
                conductionBand.style.height = `${conductionRadius * 2}px`;
                conductionBand.style.left = `${centerX - conductionRadius}px`;
                conductionBand.style.top = `${centerY - conductionRadius}px`;

                canvas.appendChild(conductionBand);
                conductionBands.push(conductionBand);
            }

            function createFreeElectronsForAtom(atomId) {
                const atom = atoms[atomId];

                // Criar aproximadamente 1 el√©tron livre por √°tomo (cobre)
                for (let i = 0; i < 1; i++) {
                    createFreeElectron(atomId);
                }
            }

            function createFreeElectron(atomId) {
                const atom = atoms[atomId];

                const freeElectron = document.createElement('div');
                freeElectron.className = 'free-electron electron';
                freeElectron.style.opacity = showElectrons && showValenceConductionElectrons ? '1' : '0';

                // Posi√ß√£o aleat√≥ria perto do √°tomo inicial
                const angle = Math.random() * 2 * Math.PI;
                const radius = 150 + Math.random() * 20;
                const x = atom.centerX + radius * Math.cos(angle);
                const y = atom.centerY + radius * Math.sin(angle);

                freeElectron.style.left = `${x - 7}px`;
                freeElectron.style.top = `${y - 7}px`;

                canvas.appendChild(freeElectron);

                const electronData = {
                    element: freeElectron,
                    atomId: atomId,
                    angle: angle,
                    radius: radius,
                    speed: 0.05 + Math.random() * 0.05,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    isFree: true,
                    targetAtomId: atomId,
                    movementProgress: 0,
                    moving: false,
                    startX: x,
                    startY: y,
                    endX: x,
                    endY: y
                };

                freeElectrons.push(electronData);
                atom.freeElectrons.push(electronData);
                totalFreeElectrons++;
            }

            function createConnections() {
                // Criar linhas de conex√£o entre √°tomos vizinhos
                atoms.forEach((atom, index) => {
                    // Conectar com √°tomo √† direita
                    if ((index + 1) % gridSize !== 0) {
                        const nextAtom = atoms[index + 1];
                        createConnectionLine(atom.centerX, atom.centerY, nextAtom.centerX, nextAtom.centerY);
                    }

                    // Conectar com √°tomo abaixo
                    if (index + gridSize < atoms.length) {
                        const belowAtom = atoms[index + gridSize];
                        createConnectionLine(atom.centerX, atom.centerY, belowAtom.centerX, belowAtom.centerY);
                    }
                });
            }

            function createConnectionLine(x1, y1, x2, y2) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                line.style.display = showConnections ? 'block' : 'none';

                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1);

                line.style.width = `${length}px`;
                line.style.left = `${x1}px`;
                line.style.top = `${y1}px`;
                line.style.transform = `rotate(${angle}rad)`;

                canvas.appendChild(line);
                connectionLines.push(line);
            }

            function updateStats() {
                // Atualizar elementos
                freeElectronCountElement.textContent = freeElectrons.length;
                conductivityValueElement.textContent = `${conductivityPercentage}%`;
                copperCountElement.textContent = copperCount;
                mainMaterialElement.textContent = copperConfig.name;
                valenceCountElement.textContent = copperConfig.valenceElectrons;
                freePerAtomElement.textContent = `‚âà${copperConfig.freeElectronsPerAtom}`;

                // Cor da condutividade
                conductivityValueElement.style.color = '#10b981';
            }

            function toggleElectronsVisibility() {
                showElectrons = !showElectrons;
                updateAllElectronsVisibility();

                toggleElectronsBtn.textContent = showElectrons ?
                    'üëÅÔ∏è Ocultar El√©trons' : 'üëÅÔ∏è Mostrar El√©trons';
                toggleElectronsBtn.classList.toggle('active', showElectrons);
            }

            function toggleInnerElectronsVisibility() {
                showInnerElectrons = !showInnerElectrons;
                updateAllElectronsVisibility();

                toggleInnerElectronsBtn.textContent = showInnerElectrons ?
                    'üåÄ Ocultar El√©trons Internos' : 'üåÄ Mostrar El√©trons Internos';
                toggleInnerElectronsBtn.classList.toggle('active', showInnerElectrons);
            }

            function toggleValenceConductionElectronsVisibility() {
                showValenceConductionElectrons = !showValenceConductionElectrons;
                updateAllElectronsVisibility();

                toggleValenceConductionElectronsBtn.textContent = showValenceConductionElectrons ?
                    '‚ö° Ocultar El√©trons Val√™ncia/Condu√ß√£o' : '‚ö° Mostrar El√©trons Val√™ncia/Condu√ß√£o';
                toggleValenceConductionElectronsBtn.classList.toggle('active', showValenceConductionElectrons);
            }

            function updateAllElectronsVisibility() {
                // Atualizar el√©trons livres (condu√ß√£o)
                freeElectrons.forEach(electron => {
                    electron.element.style.opacity = showElectrons && showValenceConductionElectrons ? '1' : '0';
                });

                // Atualizar el√©trons de val√™ncia
                valenceElectrons.forEach(electron => {
                    electron.element.style.opacity = showElectrons && showValenceConductionElectrons ? '1' : '0';
                });

                // Atualizar el√©trons internos
                innerElectrons.forEach(electron => {
                    electron.element.style.opacity = showElectrons && showInnerElectrons ? '1' : '0';
                });
            }

            function setSpeedControl(controlType) {
                currentSpeedControl = controlType;

                // Resetar todos os bot√µes
                [speedConductionBtn, speedValenceBtn, speedInnerBtn, speedAllBtn].forEach(btn => {
                    btn.classList.remove('active');
                });

                // Ativar bot√£o selecionado
                switch (controlType) {
                    case 'conduction':
                        speedConductionBtn.classList.add('active');
                        electronSpeedSlider.value = 70;
                        break;
                    case 'valence':
                        speedValenceBtn.classList.add('active');
                        electronSpeedSlider.value = 40;
                        break;
                    case 'inner':
                        speedInnerBtn.classList.add('active');
                        electronSpeedSlider.value = 20;
                        break;
                    case 'all':
                        speedAllBtn.classList.add('active');
                        electronSpeedSlider.value = 50;
                        break;
                }

                electronSpeedValue.textContent = `${electronSpeedSlider.value}%`;
                updateElectronSpeeds();
            }

            function updateElectronSpeeds() {
                const speedMultiplier = electronSpeedSlider.value / 50;

                // Aplicar velocidade baseada no controle selecionado
                switch (currentSpeedControl) {
                    case 'conduction':
                        freeElectrons.forEach(electron => {
                            electron.speed = (0.05 + Math.random() * 0.05) * speedMultiplier;
                        });
                        break;
                    case 'valence':
                        valenceElectrons.forEach(electron => {
                            electron.speed = (0.8 * speedMultiplier);
                        });
                        break;
                    case 'inner':
                        innerElectrons.forEach(electron => {
                            electron.speed = (1.0 * speedMultiplier);
                        });
                        break;
                    case 'all':
                        freeElectrons.forEach(electron => {
                            electron.speed = (0.05 + Math.random() * 0.05) * speedMultiplier;
                        });
                        valenceElectrons.forEach(electron => {
                            electron.speed = (0.8 * speedMultiplier);
                        });
                        innerElectrons.forEach(electron => {
                            electron.speed = (1.0 * speedMultiplier);
                        });
                        break;
                }
            }

            // Fun√ß√£o para aplicar for√ßa do campo el√©trico aos el√©trons
            function applyElectricField(electron) {
                const flowIntensity = flowIntensitySlider.value / 100;

                // Determinar dire√ß√£o baseado nos polos
                let directionX = 0;
                let directionY = 0;

                if (voltageApplied) {
                    // Calcular vetor do polo negativo para o positivo
                    const negativePole = electronFlowDirection === 1 ?
                        { x: negativePolePosition.x, y: negativePolePosition.y } :
                        { x: positivePolePosition.x, y: positivePolePosition.y };

                    const positivePole = electronFlowDirection === 1 ?
                        { x: positivePolePosition.x, y: positivePolePosition.y } :
                        { x: negativePolePosition.x, y: negativePolePosition.y };

                    // Vetor de dire√ß√£o (negativo ‚Üí positivo)
                    directionX = positivePole.x - negativePole.x;
                    directionY = positivePole.y - negativePole.y;

                    // Normalizar o vetor
                    const length = Math.sqrt(directionX * directionX + directionY * directionY);
                    if (length > 0) {
                        directionX /= length;
                        directionY /= length;
                    }

                    // Intensidade do campo (mais forte perto dos polos)
                    const electronX = parseFloat(electron.element.style.left) + 7;
                    const electronY = parseFloat(electron.element.style.top) + 7;

                    // Dist√¢ncia at√© os polos
                    const distToNegative = Math.sqrt(
                        Math.pow(electronX - negativePole.x, 2) +
                        Math.pow(electronY - negativePole.y, 2)
                    );

                    const distToPositive = Math.sqrt(
                        Math.pow(electronX - positivePole.x, 2) +
                        Math.pow(electronY - positivePole.y, 2)
                    );

                    // For√ßa proporcional √† dist√¢ncia (mais forte perto do polo negativo)
                    const force = flowIntensity * (1 - distToNegative / (distToNegative + distToPositive + 1));

                    return {
                        x: directionX * force * 5,
                        y: directionY * force * 5
                    };
                }

                return { x: 0, y: 0 };
            }

            // Fun√ß√£o para mover el√©trons livremente pela rede
            function moveFreeElectrons() {
                const speedMultiplier = electronSpeedSlider.value / 50;

                freeElectrons.forEach(electron => {
                    const fieldForce = applyElectricField(electron);

                    if (!electron.moving && Math.random() < 0.005 * speedMultiplier) {
                        // Decidir aleatoriamente se vai mover para outro √°tomo
                        if (voltageApplied) {
                            // Com tens√£o aplicada, preferir mover na dire√ß√£o do campo
                            const newAtomId = findAtomInDirection(electron, fieldForce);
                            if (newAtomId !== electron.atomId && newAtomId !== -1) {
                                prepareElectronMovement(electron, newAtomId);
                            }
                        } else {
                            // Sem tens√£o, movimento aleat√≥rio
                            if (Math.random() < 0.01 * speedMultiplier) {
                                const newAtomId = Math.floor(Math.random() * atoms.length);
                                if (newAtomId !== electron.atomId) {
                                    prepareElectronMovement(electron, newAtomId);
                                }
                            }
                        }
                    }

                    if (electron.moving) {
                        // Animar movimento entre √°tomos
                        electron.movementProgress += 0.02 * speedMultiplier;

                        if (electron.movementProgress >= 1) {
                            electron.moving = false;
                            electron.movementProgress = 0;
                        }

                        const progress = electron.movementProgress;
                        const x = electron.startX + (electron.endX - electron.startX) * progress;
                        const y = electron.startY + (electron.endY - electron.startY) * progress;

                        electron.element.style.left = `${x - 7}px`;
                        electron.element.style.top = `${y - 7}px`;
                    } else {
                        // Movimento orbital normal com influ√™ncia do campo el√©trico
                        const atom = atoms[electron.atomId];
                        const newAngle = electron.angle + 0.01 * electron.speed * speedMultiplier * electron.direction;

                        // Posi√ß√£o orbital
                        let x = atom.centerX + electron.radius * Math.cos(newAngle);
                        let y = atom.centerY + electron.radius * Math.sin(newAngle);

                        // Aplicar for√ßa do campo el√©trico
                        x += fieldForce.x;
                        y += fieldForce.y;

                        electron.element.style.left = `${x - 7}px`;
                        electron.element.style.top = `${y - 7}px`;

                        electron.angle = newAngle;

                        // Atualizar ocasionalmente o raio orbital
                        if (Math.random() < 0.005) {
                            electron.radius = 150 + Math.random() * 30;
                        }
                    }
                });

                // Movimento dos el√©trons de val√™ncia nas √≥rbitas
                electronAngle += 0.003 * speedMultiplier;
                valenceElectrons.forEach(electron => {
                    const atom = atoms[electron.atomId];
                    const newAngle = electron.angle + electronAngle * electron.speed;
                    const x = 70 + electron.radius * Math.cos(newAngle);
                    const y = 70 + electron.radius * Math.sin(newAngle);

                    electron.element.style.left = `${x - 7}px`;
                    electron.element.style.top = `${y - 7}px`;
                });

                // Movimento dos el√©trons internos
                innerElectrons.forEach(electron => {
                    const atom = atoms[electron.atomId];
                    const newAngle = electron.angle + electronAngle * electron.speed;
                    const x = 70 + electron.radius * Math.cos(newAngle);
                    const y = 70 + electron.radius * Math.sin(newAngle);

                    electron.element.style.left = `${x - 7}px`;
                    electron.element.style.top = `${y - 7}px`;
                });
            }

            // Encontrar √°tomo na dire√ß√£o do campo el√©trico
            function findAtomInDirection(electron, fieldForce) {
                const currentAtom = atoms[electron.atomId];
                let bestAtomId = electron.atomId;
                let bestDotProduct = -1;

                // Procurar √°tomo vizinho na dire√ß√£o do campo
                atoms.forEach((atom, atomId) => {
                    if (atomId !== electron.atomId) {
                        // Vetor do el√©tron para o √°tomo
                        const dx = atom.centerX - (parseFloat(electron.element.style.left) + 7);
                        const dy = atom.centerY - (parseFloat(electron.element.style.top) + 7);

                        // Normalizar
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length < 300) { // Apenas √°tomos pr√≥ximos
                            const normalizedDx = dx / length;
                            const normalizedDy = dy / length;

                            // Calcular produto escalar com dire√ß√£o do campo
                            const fieldLength = Math.sqrt(fieldForce.x * fieldForce.x + fieldForce.y * fieldForce.y);
                            if (fieldLength > 0) {
                                const normalizedFieldX = fieldForce.x / fieldLength;
                                const normalizedFieldY = fieldForce.y / fieldLength;

                                const dotProduct = normalizedDx * normalizedFieldX + normalizedDy * normalizedFieldY;

                                // Escolher √°tomo com maior alinhamento com o campo
                                if (dotProduct > bestDotProduct) {
                                    bestDotProduct = dotProduct;
                                    bestAtomId = atomId;
                                }
                            }
                        }
                    }
                });

                return bestAtomId;
            }

            function prepareElectronMovement(electron, newAtomId) {
                electron.moving = true;
                electron.movementProgress = 0;
                electron.startX = parseFloat(electron.element.style.left) + 7;
                electron.startY = parseFloat(electron.element.style.top) + 7;

                const targetAtom = atoms[newAtomId];
                const angle = Math.random() * 2 * Math.PI;
                const radius = 150 + Math.random() * 20;
                electron.endX = targetAtom.centerX + radius * Math.cos(angle);
                electron.endY = targetAtom.centerY + radius * Math.sin(angle);

                // Atualizar refer√™ncia do √°tomo
                electron.atomId = newAtomId;
            }

            // Fun√ß√£o de anima√ß√£o principal
            function animate() {
                moveFreeElectrons();
                animationId = requestAnimationFrame(animate);
            }

            // Fun√ß√£o para simular salto eletr√¥nico
            function simulateElectronJump() {
                // Mover alguns el√©trons de val√™ncia para a camada de condu√ß√£o
                const electronsToJump = Math.min(3, valenceElectrons.length);

                for (let i = 0; i < electronsToJump; i++) {
                    if (valenceElectrons.length === 0) break;

                    const randomIndex = Math.floor(Math.random() * valenceElectrons.length);
                    const valenceElectron = valenceElectrons[randomIndex];

                    // Remover da lista de val√™ncia
                    valenceElectrons.splice(randomIndex, 1);

                    // Criar um el√©tron livre no lugar
                    createFreeElectron(valenceElectron.atomId);

                    // Remover visualmente o el√©tron de val√™ncia
                    valenceElectron.element.style.opacity = '0';

                    // Animar transi√ß√£o
                    setTimeout(() => {
                        if (valenceElectron.element.parentNode) {
                            valenceElectron.element.parentNode.removeChild(valenceElectron.element);
                        }
                    }, 500);
                }

                updateStats();
            }

            // Fun√ß√£o para inverter os polos
            function reversePolarity() {
                electronFlowDirection *= -1;

                // Recriar os polos com as novas posi√ß√µes
                createPoleIndicators();

                // Feedback visual
                reversePolarityBtn.classList.add('active');
                setTimeout(() => {
                    reversePolarityBtn.classList.remove('active');
                }, 300);
            }

            // Atualizar valores dos sliders
            electronSpeedSlider.addEventListener('input', function () {
                electronSpeedValue.textContent = `${this.value}%`;
                updateElectronSpeeds();
            });

            flowIntensitySlider.addEventListener('input', function () {
                flowIntensityValue.textContent = `${this.value}%`;
            });

            // Controles de velocidade
            speedConductionBtn.addEventListener('click', () => setSpeedControl('conduction'));
            speedValenceBtn.addEventListener('click', () => setSpeedControl('valence'));
            speedInnerBtn.addEventListener('click', () => setSpeedControl('inner'));
            speedAllBtn.addEventListener('click', () => setSpeedControl('all'));

            // Controles de visibilidade
            toggleElectronsBtn.addEventListener('click', toggleElectronsVisibility);

            toggleConductionBtn.addEventListener('click', function () {
                showConductionBand = !showConductionBand;
                conductionBands.forEach(band => {
                    if (showConductionBand) {
                        band.classList.add('highlighted');
                        this.classList.add('active');
                    } else {
                        band.classList.remove('highlighted');
                        this.classList.remove('active');
                    }
                });
                this.textContent = showConductionBand ?
                    'üîã Ocultar Condu√ß√£o' : 'üîã Camada de Condu√ß√£o';
            });

            toggleValenceBtn.addEventListener('click', function () {
                showValenceBand = !showValenceBand;
                atoms.forEach(atom => {
                    atom.electronShells.forEach(shell => {
                        if (shell.className.includes('valence-band')) {
                            if (showValenceBand) {
                                shell.classList.add('highlighted');
                                this.classList.add('active');
                            } else {
                                shell.classList.remove('highlighted');
                                this.classList.remove('active');
                            }
                        }
                    });
                });
                this.textContent = showValenceBand ?
                    '‚ú® Ocultar Val√™ncia' : '‚ú® Camada de Val√™ncia';
            });

            toggleShellsBtn.addEventListener('click', function () {
                showInnerShells = !showInnerShells;
                atoms.forEach(atom => {
                    atom.electronShells.forEach(shell => {
                        if (shell.className.includes('inner-shell')) {
                            shell.style.display = showInnerShells ? 'block' : 'none';
                        }
                    });
                });
                this.textContent = showInnerShells ?
                    'üîÑ Ocultar Internas' : 'üîÑ Camadas Internas';
            });

            toggleConnectionsBtn.addEventListener('click', function () {
                showConnections = !showConnections;
                connectionLines.forEach(line => {
                    line.style.display = showConnections ? 'block' : 'none';
                });
                this.textContent = showConnections ?
                    'üîó Ocultar Conex√µes' : 'üîó Conex√µes';
            });

            // Novos controles de visibilidade espec√≠ficos
            toggleInnerElectronsBtn.addEventListener('click', toggleInnerElectronsVisibility);
            toggleValenceConductionElectronsBtn.addEventListener('click', toggleValenceConductionElectronsVisibility);

            // Bot√£o de aplicar tens√£o
            applyVoltageBtn.addEventListener('click', function () {
                voltageApplied = !voltageApplied;
                if (voltageApplied) {
                    this.textContent = '‚ö° Remover Tens√£o';
                    this.classList.add('active');

                    // Mostrar polos
                    if (positivePoleElement) positivePoleElement.style.display = 'flex';
                    if (negativePoleElement) negativePoleElement.style.display = 'flex';
                } else {
                    this.textContent = '‚ö° Aplicar Tens√£o';
                    this.classList.remove('active');

                    // Esconder polos
                    if (positivePoleElement) positivePoleElement.style.display = 'none';
                    if (negativePoleElement) negativePoleElement.style.display = 'none';
                }
            });

            // Bot√£o de inverter polaridade
            reversePolarityBtn.addEventListener('click', reversePolarity);

            // Bot√£o de salto eletr√¥nico
            jumpElectronsBtn.addEventListener('click', simulateElectronJump);

            // Bot√£o de randomizar
            randomizeAtomsBtn.addEventListener('click', function () {
                // Reorganizar posi√ß√£o dos el√©trons livres
                freeElectrons.forEach(electron => {
                    const randomAtomId = Math.floor(Math.random() * atoms.length);
                    const atom = atoms[randomAtomId];

                    electron.atomId = randomAtomId;
                    electron.angle = Math.random() * 2 * Math.PI;
                    electron.radius = 150 + Math.random() * 30;
                    electron.direction = Math.random() > 0.5 ? 1 : -1;

                    const x = atom.centerX + electron.radius * Math.cos(electron.angle);
                    const y = atom.centerY + electron.radius * Math.sin(electron.angle);

                    electron.element.style.left = `${x - 7}px`;
                    electron.element.style.top = `${y - 7}px`;
                });
            });

            // Bot√£o de reset
            resetSimulationBtn.addEventListener('click', function () {
                initializeSimulation();
                voltageApplied = false;
                applyVoltageBtn.textContent = '‚ö° Aplicar Tens√£o';
                applyVoltageBtn.classList.remove('active');

                // Resetar controles de velocidade
                setSpeedControl('conduction');

                // Resetar visibilidade
                showElectrons = true;
                toggleElectronsBtn.textContent = 'üëÅÔ∏è Ocultar El√©trons';
                toggleElectronsBtn.classList.add('active');

                showConductionBand = true;
                toggleConductionBtn.textContent = 'üîã Ocultar Condu√ß√£o';
                toggleConductionBtn.classList.add('active');

                showValenceBand = false;
                toggleValenceBtn.textContent = '‚ú® Camada de Val√™ncia';
                toggleValenceBtn.classList.remove('active');

                showInnerShells = false;
                toggleShellsBtn.textContent = 'üîÑ Camadas Internas';
                toggleShellsBtn.classList.remove('active');

                showConnections = true;
                toggleConnectionsBtn.textContent = 'üîó Ocultar Conex√µes';
                toggleConnectionsBtn.classList.remove('active');

                showInnerElectrons = true;
                toggleInnerElectronsBtn.textContent = 'üåÄ Ocultar El√©trons Internos';
                toggleInnerElectronsBtn.classList.add('active');

                showValenceConductionElectrons = true;
                toggleValenceConductionElectronsBtn.textContent = '‚ö° Ocultar El√©trons Val√™ncia/Condu√ß√£o';
                toggleValenceConductionElectronsBtn.classList.add('active');
            });

            // Configura√ß√£o inicial
            setSpeedControl('conduction');
            createPoleIndicators();

            // Iniciar anima√ß√£o
            animate();
        });
    </script>
</body>

</html>